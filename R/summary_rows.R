#' Add summary rows using aggregation functions
#'
#' Add groupwise summary rows to one or more row groups by using the input data
#' already provided in the \code{\link{gt}()} function alongside any suitable
#' aggregation functions. Or, add a grand summary that incorporates all
#' available data, regardless of grouping. You choose how to format the values
#' in the resulting summary cells by use of a \code{formatter} function (e.g,
#' \code{\link{fmt_number}()}) and any relevant options.
#'
#' Should we need to obtain the summary data for external purposes, the
#' \code{\link{extract_summary}()} function can be used with a \code{gt_tbl}
#' object where summary rows were added via \code{summary_rows()}.
#'
#' @param data A table object that is created using the \code{gt()} function.
#' @param groups The groups to consider for generation of groupwise summary
#'   rows. By default this is set to \code{NULL}, which results in the formation
#'   of grand summary rows (a grand summary operates on all table data).
#'   Providing the names of row groups in \code{c()} will create a groupwise
#'   summary and generate summary rows for the specified groups. Setting this to
#'   \code{TRUE} indicates that all available groups will receive groupwise
#'   summary rows.
#' @param columns The columns for which the summaries should be calculated.
#' @param fns Functions used for aggregations. This can include base functions
#'   like \code{mean}, \code{min}, \code{max}, \code{median}, \code{sd}, or
#'   \code{sum} or any other user-defined aggregation function. The function(s)
#'   should be supplied within a \code{list()}. Within that list, we can specify
#'   the functions by use of function names in quotes (e.g., \code{"sum"}), as
#'   bare functions (e.g., \code{sum}), or as one-sided R formulas using a
#'   leading \code{~}. In the formula representation, a \code{.} serves as the
#'   data to be summarized (e.g., \code{sum(., na.rm = TRUE)}). The use of named
#'   arguments is recommended as the names will serve as summary row labels for
#'   the corresponding summary rows data (the labels can derived from the
#'   function names but only when not providing bare function names).
#' @param missing_text The text to be used in place of \code{NA} values in
#'   summary cells with no data outputs.
#' @param formatter A formatter function name. These can be any of the
#'   \code{fmt_*()}functions available in the package (e.g.,
#'   \code{\link{fmt_number}()}, \code{link{fmt_percent}()}, etc.), or a custom
#'   function using \code{\link{fmt}()}. The default function is
#'   \code{\link{fmt_number}()} and its options can be accessed through
#'   \code{...}.
#' @param ... Values passed to the \code{formatter} function, where the provided
#'   values are to be in the form of named vectors. For example, when using the
#'   default \code{formatter} function, \code{\link{fmt_number}()}, options such
#'   as \code{decimals}, \code{use_seps}, and \code{locale} can be used.
#' @return An object of class \code{gt_tbl}.
#' @examples
#' # Use `sp500` to create a gt table with
#' # row groups; create summary rows (`min`,
#' # `max`, `avg`) by row group, where each
#' # each row group is a week number
#' tab_1 <-
#'   sp500 %>%
#'   dplyr::filter(
#'     date >= "2015-01-05" &
#'       date <="2015-01-16"
#'   ) %>%
#'   dplyr::arrange(date) %>%
#'   dplyr::mutate(
#'     week = paste0(
#'       "W", strftime(date, format = "%V"))
#'   ) %>%
#'   dplyr::select(-adj_close, -volume) %>%
#'   gt(
#'     rowname_col = "date",
#'     groupname_col = "week"
#'   ) %>%
#'   summary_rows(
#'     groups = TRUE,
#'     columns = vars(open, high, low, close),
#'     fns = list(
#'       min = ~min(.),
#'       max = ~max(.),
#'       avg = ~mean(.)),
#'     formatter = fmt_number,
#'     use_seps = FALSE
#'   )
#'
#' @section Figures:
#' \if{html}{\figure{man_summary_rows_1.svg}{options: width=100\%}}
#'
#' @family row addition functions
#' @export
summary_rows <- function(data,
                         groups = NULL,
                         columns = TRUE,
                         fns,
                         missing_text = "---",
                         formatter = fmt_number,
                         ...) {

  # Collect all provided formatter options in a list
  formatter_options <- list(...)

  # If `groups` is FALSE, then do nothing; just
  # return the `data` unchanged; having `groups`
  # as `NULL` signifies a grand summary, `TRUE`
  # is used for groupwise summaries across all
  # groups
  if (is_false(groups)) {
    return(data)
  }

  # Get the `stub_df` object from `data`
  stub_df <- attr(data, "stub_df", exact = TRUE)

  # Resolve the column names
  columns <- enquo(columns)
  columns <- resolve_vars(var_expr = !!columns, data = data)

  # If there isn't a stub available, create an
  # 'empty' stub (populated with empty strings);
  # the stub is necessary for summary row labels
  if (!is_stub_available(stub_df) && is.null(groups)) {

    # Place the `rowname` values into `stub_df$rowname`
    stub_df[["rowname"]] <- ""

    attr(data, "stub_df") <- stub_df
  }

  # Derive the summary labels
  summary_labels <-
    vapply(fns, derive_summary_label, FUN.VALUE = character(1))

  # If there are names, use those names
  # as the summary labels
  if (!is.null(names(summary_labels))) {
    summary_labels <- names(summary_labels)
  }

  # Append list of summary inputs to the
  # `summary` attribute
  attr(data, "summary") <-
    c(
      attr(data, "summary"),
      list(
        list(
          groups = groups,
          columns = columns,
          fns = fns,
          summary_labels = summary_labels,
          missing_text = missing_text,
          formatter = formatter,
          formatter_options = formatter_options
        )
      )
    )

  data
}

add_summary_location_row <- function(loc,
                                     data,
                                     text,
                                     df_type = "styles_df") {

  stub_df <- attr(data, "stub_df", exact = TRUE)

  row_groups <-
    stub_df[, "groupname"] %>%
    unique()

  summary_data <- attr(data, "summary", exact = TRUE)

  summary_data_summaries <-
    vapply(
      seq(summary_data),
      function(x) !is.null(summary_data[[x]]$groups),
      logical(1)
    )

  summary_data <- summary_data[summary_data_summaries]

  groups <-
    row_groups[resolve_data_vals_idx(
      var_expr = !!loc$groups,
      data = NULL,
      vals = row_groups
    )]

  # Adding styles to intersections of group, row, and column; any
  # that are missing at render time will be ignored
  for (group in groups) {

    summary_labels <-
      lapply(
        summary_data,
        function(summary_data_item) {
          if (isTRUE(summary_data_item$groups)) {
            summary_data_item$summary_labels
          } else if (group %in% summary_data_item$groups){
            summary_data_item$summary_labels
          }
        }
      ) %>%
      unlist() %>%
      unique()

    columns <-
      resolve_vars(
        var_expr = !!loc$columns,
        data = data
      )

    if (length(columns) == 0) {
      stop("The location requested could not be resolved:\n",
           " * Review the expression provided as `columns`",
           call. = FALSE)
    }

    rows <-
      resolve_data_vals_idx(
        var_expr = !!loc$rows,
        data = NULL,
        vals = summary_labels
      )

    if (length(rows) == 0) {
      stop("The location requested could not be resolved:\n",
           " * Review the expression provided as `rows`",
           call. = FALSE)
    }

    attr(data, df_type) <-
      add_location_row(
        data,
        df_type = df_type,
        locname = "summary_cells",
        locnum = 5,
        grpname = group,
        colname = columns,
        rownum = rows,
        text = text
      )
  }

  data
}

add_grand_summary_location_row <- function(loc,
                                           data,
                                           text,
                                           df_type = "styles_df") {

  summary_data <- attr(data, "summary", exact = TRUE)

  grand_summary_labels <-
    lapply(summary_data, function(summary_data_item) {
      if (is.null(summary_data_item$groups)) {
        return(summary_data_item$summary_labels)
      }

      NULL
    }) %>%
    unlist() %>%
    unique()

  columns <-
    resolve_vars(
      var_expr = !!loc$columns,
      data = data
    )

  if (length(columns) == 0) {
    stop("The location requested could not be resolved:\n",
         " * Review the expression provided as `columns`",
         call. = FALSE)
  }

  rows <-
    resolve_data_vals_idx(
      var_expr = !!loc$rows,
      data = NULL,
      vals = grand_summary_labels
    )

  if (length(rows) == 0) {
    stop("The location requested could not be resolved:\n",
         " * Review the expression provided as `rows`",
         call. = FALSE)
  }

  attr(data, df_type) <-
    add_location_row(
      data,
      df_type = df_type,
      locname = "grand_summary_cells",
      locnum = 6,
      grpname = NA_character_,
      colname = columns,
      rownum = rows,
      text = text
    )

  data
}
